// 110321 수업자료!
/*
* C언어 (절차지향.)
* C++ (C언어 + 객체지향관점 추가, STL(스택, 큐, 트리, sorting)
*
*
*
> C 기본 문법 Review
1. 포인터
2. 구조체 & 구조체 포인터
3. 동적할당
------------------------자료구조(main.c)
1. 리스트
..
..
7. 그래프
-----------------------알고리즘(main.cpp -> C언어 + C++)
1. DP
2. 그래프
   2-1. DFS
   2-2. BFS

-------------------------------------------------------------

> 리스트(List)

- 추상자료형(ADT, Abstract Data Type)
  - 구체적인 기능의 완성과정은 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것을 가리켜 '추상자료형', 'ADT'라고 한다!!

  ex) typedef struct wallet
      {
         int coin100_num;
         int bill5000_num;
      } Wallet;


  -자료구조 Wallet의 ADT 예)
    - int TakeOutMoney(Wallet* pw, int cointNum, int billNum)
      - 첫 번째 인자로 전달된 주소의 지갑에서 돈을 꺼낸다.
      - 두 번째 인자로 꺼낼 동전의 수, 세 번째 인자로 꺼낼 지폐의 수를 전달.
      - 꺼내고자 하는 돈의 총액이 반환된다. 그리고 그 만큼 돈은 차감된다.

      => 코드가 어떤식으로 구현될지? 하나도 들어있지 않다.
        변수는 뭐쓰고, 어떤 logic이 필요하고.. 이런거 포함되어 있지 않다.

    - void PutMoney(Wallet* pw, int coinNum, int billNum)
      - 첫 번째 인자로 전달된 주소의 지갑에 돈을 넣는다.
      - 두 번째 인자로 넣을 동전의 수, 세 번째 인자로 넣을 지폐의 수를 전달.
      - 넣은 만큼 동전과 지폐의 수가 증가한다.

    => C언어에서는, 이렇듯 함수를 이용해 ADT를 정의한다.


> 배열을 이용한 리스트의 구현.
  - 리스트 종류
    1. 순차 리스트 : 배열을 기반으로 구현된 리스트
    2. 연결 리스트 : 메모리의 동적 할당을 기반으로 구현된 리스트
    => 리스트의 구현 방법의 차이에서 비롯된 것.
    => ADT는 동일할 수 있다. (상황에 따라 다를 수도 있다.)

  * 리스트 자료구조의 가장 기본적이고 중요한 특성 *
    1. 리스트 자료구조는 데이터를 나란히 저장한다.
    2. 중복된 데이터의 저장을 막지 않는다.

  - 어떤 자료구조는 중복된 데이터의 저장을 허용하지 않는 경우도 있다.
    하지만, 리스트는 이를 허용한다.
  - 즉, 수학적으로 중복을 허용하지 않는 '집합'과 다르다.
  - 그리고 이것이 리스트 ADT를 정의하는데 있어 고려해야 할 유일한 요소.

  > 리스트 자료구조의 ADT
  1. void ListInit(List* plist);
    - 초기화 할 리스트의 주소 값을 인자로 전달한다.
    - 리스트 생성 후 제일 먼저 호출되어야 하는 함수이다.

  2. void LInsert(List* plist, LData data);
    - 리스트에 데이터를 저장한다.
    - 매개변수 data에 전달된 값을 저장한다.

  3. int LFirst(List* plist, LData* pdata);
    - 첫번째 데이터가 pdata가 가리키는 메모리에 저장된다.
    - 데이터의 참조를 위한 초기화가 진행된다.
    - 참조 성공 시 True(1), 실패 시 False(0) 반환

  4. int LNext(List* plist, LData* pdata);
    - 참조된 데이터의 다음 데이터가 pdata가 가리키는 메모리에 저장된다.
    - 순차적인 참조를 위해서 반복 호출이 가능하다.
    - 참조를 새로 시작하려면 먼저 LFirst 함수를 호출해야 한다.
    - 참조 성공 시 True(1), 실패 시 False(0) 반환

  5. LData LRemove(List* plist);
    - LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제한다.
    - 삭제된 데이터는 반환된다.
    - 마지막 반환 데이터를 삭제하므로 연이은 반복 호출을 허용하지 않는다.

  6. int LCount(List* plist);
    - 리스트에 저장되어 있는 데이터의 수를 반환한다.


ex1) 01_List - ListUseMain.c 파일 작성.

     ArrayList.h, ArrayList.c 2가지 파일을 프로젝트에 포함시키자.
     이를 기반으로 다음의 순서대로 일이 진행되도록 main 함수를 정의해보자.
     1. 리스트 생성 및 초기화 한 다음, 정수 1 ~ 9까지 리스트에 저장한다.
     2. 리스트에 저장된 값을 순차적으로 참조하여 그 합을 계산하여 출력한다.
     3. 리스트에 저장된 값들 중 2의 배수와 3의 배수에 해당하는 값을 모두 삭제 한다.
     4. 마지막으로 리스트에 저장된 데이터를 순서대로 출력한다.


ex2) 01_List_2 - NameCard.c & NameCardListMain.c 2개의 파일 작성.

     NameCard.h 헤더파일을 프로젝트에 포함시키자.
     이 헤더파일에 대응하는 소스파일 NameCard.c를 작성하자.
     그리고 아래에 나열된 순서대로 일을 진행하도록 main 함수를 정의하자.
     (앞서 구현한 ArrayList.h, ArrayList.c를 활용.)
     1. 총 3명의 전화번호 정보를, 앞서 우리가 구현한 리스트에 저장한다.
     2. 특정 이름을 대상으로 탐색을 진행하여, 그 사람의 정보를 출력한다.
     3. 특정 이름을 대상으로 탐색을 진행하여, 그 사람의 전화번호 정보를 변경한다.
     4. 특정 이름을 대상으로 탐색을 진행하여, 그 사람의 정보를 삭제한다.
     5. 끝으로 남아있는 모든 사람의 전화번호 정보를 출력한다.

     * 저장의 형태는 NameCard 구조체 변수의 주소 값이어야 하며,
     * 위에서 언급한 특정 이름은 임의로 지정하되, 서로 다른 이름으로 지정하자.


>배열 기반 리스트 단점
  - 배열 길이가 초기에 결정되어야 함. (변경 불가능)
  - 삭제 과정에서 데이터 복사가 매우 빈번히 일어남

>배열 기반 리스트 장점
  - 데이터 참조가 쉬움. 인덱스 값 기준으로 어디든 한번에 참조 가능.

-----------------------------------------------------------------------> 02_List Start

> 연결 리스트

  1. LinkedRead.c 이해하기.

  ex3) LinkedRead.c를 수정해보자.
      새 노드를 연결 리스트의 꼬리가 아닌 머리에 추가하도록 수정하자.
      원래는, 3->2->7->8의 연결 리스트에 5를 추가로 삽입하면, 3->2->7->8->5
      근데 이걸, 5->3->2->7->8 이렇게 되도록 수정하기.

      sol) HeadAddLinkedRead.c


  2. 연결 리스트의 ADT와 구현
  - 연결의 형태가 한쪽 방향으로 전개되고 시작과 끝이 존재하는 '단순 연결 리스트'
  - 사실 순차 리스트의 ADT를 그대로 적용해도 됨.
  - 하지만 정렬 기능 추가하기 위해 ADT를 조금 확장해서 정의하자.

  1. void ListInit(List* plist);
     - 초기화할 리스트의 주소값을 인자로 전달.
     - 리스트 생성 후 제일 먼저 호출 되어야 하는 함수.

  2. void LInsert(List* plist, LData data);
     - 리스트에 데이터를 저장. 매개변수 data에 전달된 값을 저장.

  3. int LFirst(List* plist, LData* pdata);
     - 첫번째 데이터가 pdata가 가리키는 메미로에 저장.
     - 데이터의 참조를 위한 초기화 진행
     - 참조 성공 시 True(1), 실패 시 False(0) 반환

  4. int LNext(List* plist, LData* pdata);
     - 참조된 데이터의 다음 데이터가 pdata가 가리키는 메모리에 저장됨.
     - 순차적인 참조를 위해 반복 호출이 가능함.
     - 참조를 새로 시작하려면 먼저 LFirst 함수를 호출해야 함.
     - 참조 성공 시 True(1), 실패 시 False(0) 반환

  5. LData LRemove(List* plist);
     - LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제.
     - 삭제된 데이터는 반환
     - 마지막 반환 데이터를 삭제하므로 연이은 반복 호출을 허용하지 않는다.

  6. int LCount(List* plist);
     - 리스트에 저장되어 있는 데이터 수를 반환

  7. void SetSortRule(List* plist, int (*comp)(LData d1, Ldata d2));
     - 리스트에 정렬의 기준이 되는 함수를 등록.
     - ex) int Func(LData d1, LData d2) // typedef int LData
           {
               if (d1 < d2) return 0;
               else return 1;
           }


  > 새 노드를 추가할 때, 리스트의 머리와 꼬리 중 어디에 저장할까?
    - 머리에 추가하면
      - 장점 : 포인터 변수 tail 불필요
      - 단점 : 저장된 순서 유지 X
    - 꼬리에 추가하면
      - 장점 : 저장된 순서 유지
      - 단점 : 포인터 변수 tail 필요

    => 보통은 머리에 추가함. 왜냐면 tail 변수 관련 코드가 번거로울 수 있음.
    => 저장된 순서 유지 안되도 괜찮음. 순서를 유지해야 하는 자료구조가 아니거든.


> 더미 노드(Dummy node) 기반의 단순 연결리스트
  - 앞선 예제의 연결리스트 구조               ↓ tail
    head -> [2, *] -> [4, *] -> [6, *] -> [8, *]

    - 구현적 측면에서 볼 때, 이런 구조의 단점이 뭘까?
    - 노드 추가,삭제, 조회 할때, 첫번째 노드 / 두번째 이후 노드의 접근 방법 차이가 있다.
      - 첫번째 노드는 head가 직접 가리킴.
      - 두번째 이후엔 node->next

  - 이를 개선한 연결리스트 구조
    head -> [DUMMY, *] -> [2, *] -> [4, *] -> ..

    - tail 사라짐
    - dummy node 추가.
      - 아무런 데이터 없음
      - 처음 추가되는 노드가, 구조상 두번째 노드가 되므로 노드의 추가/삭제/조회 시 코드가 일관된 형태로 가능.


   ex4) LinkedRead.c에서 생성하는 연결 리스트에, 더미 노드를 추가해보자.
        tail은 일단 놔두고, 더미 노드만을 추가해서 코드 정상적으로 잘 동작하도록 수정해보고, 이해하자.

        head -> [DUMMY, *] -> [2, *] -> [4, *] <- tail

        sol) DLinkedRead.c


> DLinkedList.h
  - 현재까지는, main 함수에 Node* head; 선언 했었는데, 리스트 종류가 많아질 때 마다, 필요한 변수들을 매번 선언할 수 없다.

  - 연결리스트를 위한 구조체를 포함한, 함수 선언들을 DLinkedList.h 파일에 모아놓자!
    - 함수 ADT는, 기존의 순차 리스트와 동일한데, 정렬기준 저장을 위한 SetSortRule()만 추가됨.


  > DLinkedList.c & DLinkedListSortMain.c 이해하기!!
    - 자료구조할 때, 흐름 다 확실히 이해할 수 있고, 그걸 바탕으로 ADT 수정 및 main 수정 할 수 있으면 충분하다.
    - 자료구조 자체를 모두 구현하는 것은, C언어 문법 및 구현 연습엔 좋다.
    - 자료구조 모델을 이해하고, 어떻게 활용할 수 있을지 감 잡으면 된다.
*/


/*
> C 기본 문법 Review
1. 포인터 (=> A함수에서 다른 함수들(지역)의 변수에 접근하기 위해)
*/



/*
#include<stdio.h>

void SWAP(int* p1, int* p2)
{
    int tmp = *p1;
    *p1 = *p2;
    *p2 = tmp;
}

int main(void)
{
    int n1 = 10;
    int n2 = 20;

    printf("n1 : %d, n2 : %d\n", n1, n2);

    SWAP(&n1, &n2); // 이 함수 호출 뒤에, n1 <-> n2 값이 바뀌길 원해.

    printf("n1 : %d, n2 : %d\n", n1, n2);

    return 0;
}
*/

